package com.android.camera.effect.renders;

import com.android.gallery3d.ui.GLCanvas;
import java.nio.IntBuffer;

public class VscoF2EffectRender extends RGBTransEffectRender {
    private static final int[] sRGBLut = new int[]{0, 1, 1, 2, 3, 3, 4, 5, 6, 6, 7, 8, 8, 9, 10, 10, 11, 12, 13, 13, 14, 15, 15, 16, 17, 18, 18, 19, 20, 21, 21, 22, 23, 24, 24, 25, 26, 27, 28, 28, 29, 30, 31, 32, 32, 33, 34, 35, 36, 37, 38, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 64, 65, 66, 67, 68, 69, 71, 72, 73, 74, 75, 77, 78, 79, 80, 81, 83, 84, 85, 86, 88, 89, 90, 91, 93, 94, 95, 97, 98, 99, 100, 102, 103, 104, 106, 107, 108, 109, 111, 112, 113, 114, 116, 117, 118, 120, 121, 122, 123, 125, 126, 127, 128, 129, 131, 132, 133, 134, 135, 137, 138, 139, 140, 141, 143, 144, 145, 146, 147, 148, 149, 151, 152, 153, 154, 155, 156, 157, 158, 159, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 235, 236, 237, 238, 239, 240, 241, 242, 243, 243, 244, 245, 246, 247, 248, 249, 250, 251, 251, 252, 253, 254, 255};
    private static IntBuffer sRGBLutBuffer;

    private static IntBuffer getRGBLutBuffer() {
        if (sRGBLutBuffer == null) {
            for (int i = 0; i < sRGBLut.length; i++) {
                sRGBLut[i] = (((sRGBLut[i] << 16) | -16777216) | (sRGBLut[i] << 8)) | sRGBLut[i];
            }
            sRGBLutBuffer = IntBuffer.wrap(sRGBLut);
        }
        sRGBLutBuffer.rewind();
        return sRGBLutBuffer;
    }

    public VscoF2EffectRender(GLCanvas canvas, int id) {
        super(canvas, id);
        setRGBTransLutBuffer(getRGBLutBuffer());
    }

    public String getFragShaderString() {
        return "precision mediump int; \nprecision mediump float; \nuniform sampler2D sTexture; \nuniform sampler2D sRGBLut; \nvarying vec2 vTexCoord; \nuniform float uAlpha; \nbool isContain(vec3 color, int select_color) { \n    bool result = false; \n    if (select_color == 0) {        //红色 \n        result = (color.r > color.g) && (color.r > color.b); \n    } else if (select_color == 1) { //黄色 \n        result = (color.r > color.b) && (color.g > color.b); \n    } else if (select_color == 2) { //绿色 \n        result = (color.g > color.r) && (color.g > color.b); \n    } else if (select_color == 3) { //青色 \n        result = (color.g > color.r) && (color.b > color.r); \n    } else if (select_color == 4) { //蓝色 \n        result = (color.b > color.r) && (color.b > color.g); \n    } else if (select_color == 5) { //洋红 \n        result = (color.r > color.g) && (color.b > color.g); \n    } else if (select_color == 6) { //黑色 \n        result = (color.r < 0.5) && (color.g < 0.5) && (color.b < 0.5); \n    } else if (select_color == 7) { //灰色 \n        result = (color.r < 1.0) && (color.g < 1.0) && (color.b < 1.0) && \n                 (color.r > 0.0) && (color.g > 0.0) && (color.b > 0.0); \n    } else if (select_color == 8) { //白色 \n        result = (color.r > 0.5) && (color.g > 0.5) && (color.b > 0.5); \n    } \n    return result; \n} \nvec3 SelectiveColor(vec3 color, int select_color, vec4 tune_values) { \n    float R = color.r; \n    float G = color.g; \n    float B = color.b; \n    if (isContain(color, select_color)) { \n        float max_V = max(R, max(G, B)); \n        float min_V = min(R, min(G, B)); \n        float mid_V = R + G + B - max_V - min_V; \n        float V_range = 0.0; \n        if (select_color == 0 || select_color == 2 || select_color == 4) { \n            V_range = max_V - mid_V; \n        } else if (select_color == 1 || select_color == 3 || select_color == 5) { \n            V_range = mid_V - min_V; \n        } else if (select_color == 7) { \n            V_range = 1.0 - abs(max_V-0.5) + abs(min_V-0.5); \n        } else if (select_color == 8) { \n            V_range = (min_V-0.5) * 2.0; \n        } else if (select_color == 6) { \n            V_range = (0.5-max_V) * 2.0; \n        } \n        vec4 fr_max = vec4(    R,     G,     B, 1.0); \n        vec4 fl_max = vec4(1.0-R, 1.0-G, 1.0-B, 1.0); \n        vec3 rgb = color; \n        float delta = 0.0; \n        if (tune_values.r > 0.0) { \n            rgb.r = color.r - V_range * min( tune_values.r, fr_max.r); \n        } else if (tune_values.r < 0.0) { \n            rgb.r = color.r + V_range * min(-tune_values.r, fl_max.r); \n        } \n        delta = (rgb.r - color.r) / V_range; \n        if (tune_values.a > 0.0) { \n            rgb.r = color.r - V_range * min( tune_values.a, fr_max.r+delta); \n        } else if (tune_values.a < 0.0) { \n            rgb.r = color.r + V_range * min(-tune_values.a, fl_max.r-delta); \n        } \n        if (tune_values.g > 0.0) { \n            rgb.g = color.g - V_range * min( tune_values.g, fr_max.g); \n        } else if (tune_values.g < 0.0) { \n            rgb.g = color.g + V_range * min(-tune_values.g, fl_max.g); \n        } \n        delta = (rgb.g - color.g) / V_range; \n        if (tune_values.a > 0.0) { \n            rgb.g = color.g - V_range * min( tune_values.a, fr_max.g+delta); \n        } else if (tune_values.a < 0.0) { \n            rgb.g = color.g + V_range * min(-tune_values.a, fl_max.g-delta); \n        } \n        if (tune_values.b > 0.0) { \n            rgb.b = color.b - V_range * min( tune_values.b, fr_max.b); \n        } else if (tune_values.b < 0.0) { \n            rgb.b = color.b + V_range * min(-tune_values.b, fl_max.b); \n        } \n        delta = (rgb.b - color.b) / V_range; \n        if (tune_values.a > 0.0) { \n            rgb.b = color.b - V_range * min( tune_values.a, fr_max.b+delta); \n        } else if (tune_values.a < 0.0) { \n            rgb.b = color.b + V_range * min(-tune_values.a, fl_max.b-delta); \n        } \n        color = rgb; \n    } \n    return color; \n} \nvec3 TuneLevels(vec3 color, float minInput, float maxInput, float gamma, float minOutput, float maxOutput, int mod) { \n    if (mod == 4 || mod == 0) { \n        float value_ = pow(min(max(color.r - minInput, 0.0) / (maxInput - minInput), 1.0), 1.0/gamma); \n        color.r = maxOutput * value_ + minOutput * (1.0 - value_); \n    } else if (mod == 4 || mod == 1) { \n        float value_ = pow(min(max(color.g - minInput, 0.0) / (maxInput - minInput), 1.0), 1.0/gamma); \n        color.g = maxOutput * value_ + minOutput * (1.0 - value_); \n    } else if (mod == 4 || mod == 2) { \n        float value_ = pow(min(max(color.b - minInput, 0.0) / (maxInput - minInput), 1.0), 1.0/gamma); \n        color.b = maxOutput * value_ + minOutput * (1.0 - value_); \n    } \n    return color; \n} \nvec3 adjust_contrast(vec3 color, float f_contrast) { \n    float ff = log(1.0 - f_contrast) / log(0.5); \n    float r = color.r, g = color.g, b = color.b; \n    if (r < 0.5) { \n        r = pow(2.0 * r, ff) / 2.0; \n    } else { \n        r = 1.0 - pow(2.0 * (1.0 - r), ff) / 2.0; \n    } \n    if (g < 0.5) { \n        g = pow(2.0 * g, ff) / 2.0; \n    } else { \n        g = 1.0 - pow(2.0 * (1.0 - g), ff) / 2.0; \n    } \n    if (b < 0.5) { \n        b = pow(2.0 * b, ff) / 2.0; \n    } else { \n        b = 1.0 - pow(2.0 * (1.0 - b), ff) / 2.0; \n    } \n    return vec3(r, g, b); \n} \nvec3 adjust_light(vec3 color, float f_light, float ff_ll) { \n    color.r = pow(color.r, ff_ll); \n    color.r = (color.r * f_light) / (2.0 * color.r * f_light - color.r - f_light + 1.0); \n    color.r = pow(color.r, 1.0 / ff_ll); \n    color.g = pow(color.g, ff_ll); \n    color.g = (color.g * f_light) / (2.0 * color.g * f_light - color.g - f_light + 1.0); \n    color.g = pow(color.g, 1.0 / ff_ll); \n    color.b = pow(color.b, ff_ll); \n    color.b = (color.b * f_light) / (2.0 * color.b * f_light - color.b - f_light + 1.0); \n    color.b = pow(color.b, 1.0 / ff_ll); \n    color = clamp(color, 0.0, 1.0); \n    return color; \n} \nvoid main() { \n    vec3 color = texture2D(sTexture, vTexCoord).rgb; \n    int select_color = 3; \n    vec4 tune_values = vec4(0.13, 0.26, 1.0, 0.05); \n    color = SelectiveColor(color, select_color, tune_values); \n    select_color = 5; \n    tune_values = vec4(0.2, -0.08, 0.53, -0.16); \n    color = SelectiveColor(color, select_color, tune_values); \n    select_color = 8; \n    tune_values = vec4(0.39, 0.0, 0.0, -0.14); \n    color = SelectiveColor(color, select_color, tune_values); \n    color = clamp(color, 0.0, 1.0); \n    vec3 index; \n    index.r = float(int(color.r * 255.0)) / 256.0; \n    index.g = float(int(color.g * 255.0)) / 256.0; \n    index.b = float(int(color.b * 255.0)) / 256.0; \n    color.r = texture2D(sRGBLut, vec2(index.r, 0.0)).r; \n    color.g = texture2D(sRGBLut, vec2(index.g, 0.0)).g; \n    color.b = texture2D(sRGBLut, vec2(index.b, 0.0)).b; \n    color = clamp(color, 0.0, 1.0); \n    color = TuneLevels(color, 13.0/255.0, 1.0, 1.37, 0.0, 1.0, 4); \n    color = TuneLevels(color, 0.0, 1.0, 0.97, 0.0, 1.0, 0); \n    select_color = 0; \n    tune_values = vec4(-0.1, 0.0, -0.07, 0.1); \n    color = SelectiveColor(color, select_color, tune_values); \n    select_color = 1; \n    tune_values = vec4(0.0, 0.03, -0.34, -0.15); \n    color = SelectiveColor(color, select_color, tune_values); \n    select_color = 2; \n    tune_values = vec4(-0.16, 0.58, 0.07, 0.2); \n    color = SelectiveColor(color, select_color, tune_values); \n    select_color = 4; \n    tune_values = vec4(0.86, -0.29, 0.17, -0.33); \n    color = SelectiveColor(color, select_color, tune_values); \n    select_color = 4; \n    tune_values = vec4(0.0, 0.08, 0.34, 0.09); \n    color = SelectiveColor(color, select_color, tune_values); \n    float bri = 0.5 + 3.0 / 155.0; \n    float ff_ll = 2.2; \n    color = adjust_light(color, bri, ff_ll); \n    color = adjust_contrast(color, 0.545); \n    gl_FragColor = vec4(color, 1.0) * uAlpha; \n} \n";
    }
}
